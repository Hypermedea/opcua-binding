package org.hypermedea.opcua;

import ch.unisg.ics.interactions.wot.td.affordances.Form;
import ch.unisg.ics.interactions.wot.td.bindings.*;
import ch.unisg.ics.interactions.wot.td.vocabularies.TD;
import org.eclipse.milo.opcua.sdk.client.OpcUaClient;
import org.eclipse.milo.opcua.sdk.client.api.config.OpcUaClientConfig;
import org.eclipse.milo.opcua.sdk.client.api.config.OpcUaClientConfigBuilder;
import org.eclipse.milo.opcua.stack.core.UaException;
import org.eclipse.milo.opcua.stack.core.types.builtin.LocalizedText;
import org.eclipse.milo.opcua.stack.core.types.structured.EndpointDescription;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.function.Function;

import static org.eclipse.milo.opcua.sdk.client.OpcUaClient.create;

/**
 * <p>
 *   OPC UA binding for W3C Web of Things (WoT) forms. The OPC UA binding expects forms with target URIs having
 *   the {@code opc.tcp} scheme.
 * </p>
 * <p>
 *   The current implementation only supports reading and writing OPC UA nodes of type Variable,
 *   interpreted as {@code readProperty} and {@code writeProperty} operations. See {@link OPCUA} for a
 *   documentation of allowed terms in WoT forms targeting OPC UA.
 * </p>
 */
public class OpcUaBinding extends BaseProtocolBinding {

    public static final String OPC_UA_PROTOCOL = "OPC UA";

    public static final String OPC_UA_SCHEME = "opc.tcp";

    /**
     * Clients used in {@link Operation} generated by calls to {@link #bind(Form, String)}.
     * By reusing the same client, several operations targeting the same OPC UA server
     * will require only a single connection.
     */
    private Map<String, OpcUaClient> connections = new HashMap<>();

    @Override
    public String getProtocol() {
        return OPC_UA_PROTOCOL;
    }

    @Override
    public Collection<String> getSupportedSchemes() {
        Set<String> singleton = new HashSet<>();
        singleton.add(OPC_UA_SCHEME);

        return singleton;
    }

    @Override
    public Optional<String> getDefaultMethod(String operationType) {
        return Optional.empty();
    }

    @Override
    public Optional<String> getDefaultSubProtocol(String operationType) {
        return Optional.empty();
    }

    /**
     * <p>
     *     See {@link ProtocolBinding#bind(Form, String)}.
     * </p>
     * <p>
     *     The {@code OpcUaBinding} object maintains a list of open connections, such that
     *     whenever it binds a form to a specific OPC UA operation, it first look up its list of open connections.
     *     If the OPC UA endpoint given in the input form is already known, an existing OPC UA client
     *     (whose connection is supposed to be active) is used for the operation. If the endpoint
     *     is not known yet, a new client is created and connection to the server is immediately attempted.
     *     If connection is established, the client is added to the list of open connections and the newly
     *     created client is used for the operation. If the client cannot connect, it is assumed the form
     *     contains invalid information (e.g. incorrect endpoint URI).
     * </p>
     *
     * @param form the WoT form to bind
     * @param operationType the operation type (one of {@code readProperty} or {@code writeProperty})
     * @return an operation to be executed against a connected OPC UA server
     * @throws InvalidFormException if the server's URI is invalid or the operation type is not supported
     */
    @Override
    public Operation bind(Form form, String operationType) throws InvalidFormException {
        try {
            URI uri = new URI(form.getTarget());

            if (!uri.getScheme().equals(OPC_UA_SCHEME)) {
                throw new InvalidFormException(String.format("URI unrecognized by OPC UA binding: %s", form.getTarget()));
            }

            OpcUaClient c = connections.get(form.getTarget());

            if (c == null) {
                c = createClient(form.getTarget());
                connections.put(form.getTarget(), c);
            }

            // TODO check client is still connected

            switch (operationType) {
                case TD.readProperty: return new ReadOperation(form, c);
                case TD.writeProperty: return new WriteOperation(form, c);

                default: throw new InvalidFormException("Operation type not supported by OPC UA binding");
            }
        } catch (URISyntaxException e) {
            throw new InvalidFormException(String.format("URI not well-formed: %s", form.getTarget()));
        }
    }

    private OpcUaClient createClient(String endpointUri) {
        Function<List<EndpointDescription>, Optional<EndpointDescription>> sel = eps -> eps.stream().findFirst();

        Function<OpcUaClientConfigBuilder, OpcUaClientConfig> build = b ->
                b.setApplicationName(LocalizedText.english("Hypermedea OPC UA protocol binding"))
                 .setApplicationUri("https://hypermedea.github.io/#this")
                 .build();

        try {
            OpcUaClient client = create(endpointUri, sel, build);

            client.connect().get(); // blocking operation
            return client;
        } catch (UaException e) {
            throw new InvalidFormException("OPC UA client cannot be created based on form information", e);
        } catch (InterruptedException e) {
            // TODO retry instead
            throw new RuntimeException(e);
        } catch (ExecutionException e) {
            // TODO log and retry instead
            throw new RuntimeException(e);
        }
    }

}
